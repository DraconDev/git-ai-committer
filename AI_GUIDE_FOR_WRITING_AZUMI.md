# Comprehensive AI Guide to Writing Azumi Code

> A complete reference guide for AI assistants helping developers write Azumi applications, covering all features and patterns.

## üéØ Philosophy & Core Concepts

Azumi is a **compiler-driven optimistic UI framework** that generates client-side predictions from Rust code. Write logic once, get instant UI updates everywhere.

-   **Single Source of Truth**: Rust code is the only source of truth
-   **Compile-Time Safety**: Macros catch errors before runtime
-   **Zero JavaScript**: Compiler generates all client logic
-   **Server-Side Truth**: Server always wins, client predictions are optimistic

---

## üö® Critical Rules (Absolute Must-Know)

### 1. CSS Values MUST Be Double-Quoted

```rust
// ‚úÖ CORRECT - all values quoted
.btn {
    padding: "1rem";
    background: "#4CAF50";
    color: "white";
    border-radius: "8px";
}

// ‚ùå WRONG - will cause compile errors or lexer issues
.btn {
    padding: 1rem;      // Lexer can't parse "1rem" as token
    background: #4CAF50; // # causes parsing issues
    color: white;        // Unquoted identifier
}
```

### 2. CSS Classes (`class={...}`) - **STRICT MODE**

-   **Strict Snake Case:** All CSS classes MUST be `snake_case`. Dashes (`-`) are **BANNED** in class names (e.g., Use `.my_card`, NOT `.my-card`). The compiler will reject dashed names.
-   **Bracket Syntax ONLY:** You must use brackets with variables `class={my_class}`. Static strings usage (`class="my_class"`) is **BANNED** and will cause a compile error.
-   **No Magic:** Automatic scoping handles everything via variables.
-   **Expression Lists:** You can combine multiple class variables: `class={card active}`.

```rust
html! {
    // ‚úÖ CORRECT: Use variables generated by macros
    <div class={my_card}>...</div>

    // ‚úÖ CORRECT: Combine multiple classes
    <div class={my_card active}>...</div>

    // ‚ùå INCORRECT: Quoted strings are BANNED
    // <div class="my_card">...</div>

    // ‚ùå INCORRECT: Dashed names are invalid Rust identifiers
    // <div class={my-card}>...</div>

    <style>
        .my_card { ... }
        .active { ... }
    </style>
    }
```

### 3. IDs (`id={...}`)

-   Same rules as classes: **Snake Case** and **Bracket Syntax ONLY**.
-   `id="..."` is **BANNED**.

```rust
html! {
    <div id={my_unique_id}>...</div>
    <style>
        #my_unique_id { ... }
    </style>
}
```

### 4. Inline Styles (`style={...}`)

-   Use the **Style DSL** with brackets.
-   `style="..."` string syntax is **BANNED**.

```rust
// ‚úÖ CORRECT
<div style={ --color: "red"; --spacing: "1rem" }>...</div>

// ‚ùå INCORRECT
// <div style="--color: red">...</div>
```

### 5. Live State Requires Component Link

```rust
// State definition
#[azumi::live]
pub struct Counter { pub count: i32 }

// Implementation MUST specify component
#[azumi::live_impl(component = "counter_view")]  // ‚Üê Required!
impl Counter {
    pub fn increment(&mut self) { self.count += 1; }
}

// Component MUST match the name
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a {
    html! { /* ... */ }
}
```

### 6. Event Binding Syntax

```rust
// ‚úÖ CORRECT - use on:event={state.method}
<button on:click={state.increment}>"Click"</button>

// ‚ùå WRONG - don't use closures or function calls
<button on:click={|| state.increment()}>"Click"</button>
<button on:click={state.increment()}>"Click"</button>
```

### 7. Text Content Must Be Quoted

```rust
// ‚úÖ CORRECT - all text in quotes
<p>"Hello world"</p>
<p>"Count: " {count}</p>

// ‚ùå WRONG - will cause parsing errors
<p>Hello world</p>
```

### 8. Style Order: HTML First, Style Last

For readability and consistency, always place your `<style>` block **after** your HTML content.

```rust
html! {
    // 1. Structure
    <div class={container}>...</div>

    // 2. Style
    <style>
        .container { ... }
    </style>
}
```

---

## üöÄ Setup & Configuration

### Client Runtime (Manual)

The Azumi client runtime (`azumi.js`) must be **manually injected** in your root layout to enable interactive features.

#### How It Works

1.  **You Add the Script**: Place `<script src="azumi.js" />` in your root layout.
2.  **The Route is Served Automatically**: `azumi::action::register_actions()` serves the file.

```rust
#[azumi::component]
pub fn RootLayout(children: impl Component) -> impl Component {
    html! {
        <!DOCTYPE html>
        <html>
            <head>
                <meta charset="utf-8" />
                <title>"My Azumi App"</title>
            </head>
            <body>
                {children}
                // ‚úÖ REQUIRED: Manually include the runtime for interactivity
                <script src="azumi.js" />
            </body>
        </html>
    }
}
```

> [!NOTE] > **Why Manual?** Azumi defaults to zero-JS static HTML. You opt-in to interactivity by adding the script.

---

## üîå Server-Side Integration (Axum)

Azumi is designed to run on top of **Axum**. You possess full control over the server, routing, and middleware.

### 1. Routing & Handlers

Routing is **manual and explicit**. You map routes to async handler functions in `main.rs`.

**Handler Pattern:**

1.  Define an async function.
2.  Perform data fetching (DB, API) inside the handler.
3.  Pass data to the component.
4.  Render the component to a string response.

```rust
// 1. Logic & Data Fetching (The Handler)
pub async fn profile_handler(Path(user_id): Path<String>) -> impl IntoResponse {
    // A. Fetch Data (Async)
    let user = db::get_user(&user_id).await.expect("User not found");

    // B. Render Component
    // Pass strictly typed data to the component
    let view = ProfilePage(user);

    // C. Return HTML
    Html(azumi::render_to_string(&view))
}

// 2. The Component (Pure Presentation)
#[azumi::page]
fn ProfilePage(user: User) -> impl Component {
    html! {
        <h1>"Hello, " {user.name}</h1>
    }
}

// 3. Mount in main.rs
let app = Router::new()
    .route("/profile/:id", get(profile_handler));
```

### 2. Middleware

Use standard Axum middleware layers to handle cross-cutting concerns like Auth, Logging, or Compression.

```rust
let app = Router::new()
    .route("/", get(home_handler))
    .layer(axum::middleware::from_fn(auth_middleware)); // Apply to all routes
```

---

## ‚ö° Interactivity: Live vs Actions

Azumi offers two ways to handle interactivity.

### 1. Azumi Live (Recommended for UI State)

Use **Live** when you have state that stays on the page and updates interactively.

-   **Best for**: Toggles, Counters, Tabs, Wizards, Filters.
-   **Features**: Optimistic UI (instant updates), Type-safe bindings.

```rust
#[azumi::live]
pub struct Counter { count: i32 }
// ... methods ...
```

### 2. Server Actions (Recommended for Forms / RPC)

Use **Actions** when you want to handle an event or submit data without maintaining UI state.

-   **Best for**: Forms (Login, Contact), One-off buttons (Logout, Delete), Redirects.
-   **Features**: Zero-overhead (no state serialization), works with standard `<form>`.

```rust
// A basic payload (or use axum::Form for standard forms)
#[derive(Deserialize)]
pub struct ContactForm { email: String, msg: String }

#[azumi::action]
pub async fn submit_contact(data: ContactForm) -> impl Component {
    // Process data...
    html! { <div>"Thanks for your message!"</div> }
}

// In your view:
// <form az-on="submit call submit_contact -> #result"> ...
```

---

## ‚ö° Azumi Live Implementation Details

Azumi Live is the **recommended** way to add interactivity. It uses compiler analysis to predict UI updates before the server responds.

### 1. Define State with `#[azumi::live]`

Mark your state struct. This enables serialization and prediction.

```rust
#[azumi::live]
pub struct Counter {
    pub count: i32,
    pub active: bool,
}
```

### 2. Define Methods with `#[azumi::live_impl]`

The `component` attribute links to the view function that renders this state.

```rust
#[azumi::live_impl(component = "counter_view")]
impl Counter {
    pub fn increment(&mut self) {
        self.count += 1;
    }

    pub fn toggle(&mut self) {
        self.active = !self.active;
    }
}
```

### 3. Create the Component

The component receives a reference to the state. Use `on:click={state.increment}` for event binding.

```rust
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a {
    html! {
        <div class={counter_box}>
            <div data-bind="count">{state.count}</div>
            <button on:click={state.increment}>"+ Increment"</button>
            <button on:click={state.toggle}>"Toggle"</button>
        </div>
    }
}
```

### 4. How It Works

1.  **Compiler Analysis**: `#[azumi::live_impl]` analyzes method bodies to generate **predictions**.
2.  **Optimistic Update**: When you click, the client updates the UI _immediately_ based on the prediction.
3.  **Server Reconciliation**: The server runs the actual method and sends back the real HTML.
4.  **Morphing**: The client morphs the DOM to match the server response (usually identical).

### 5. `data-bind` for Optimistic Updates

Use `data-bind="field_name"` on elements that should update instantly:

```rust
// This element updates BEFORE the server responds
<div data-bind="count">{state.count}</div>
```

### 6. Using in a Page

```rust
#[azumi::page]
pub fn my_page() -> impl Component {
    let state = Counter { count: 0, active: true };
    html! {
        @DarkModernLayout() {
            @counter_view(state = &state)
        }
    }
}
```

> [!NOTE] > **When to Use**: Azumi Live is best for simple, predictable mutations (toggles, counters). For complex state or DB-driven updates, use server actions directly.

---

## ÔøΩ Common Patterns & Recipes

### üü¢ Azumi Live Pattern: Instant Toggle (e.g., Like Button)

Use this for interactions that should feel "instant" to the user.

```rust
#[azumi::live]
pub struct LikeState { pub liked: bool, pub count: i32 }

#[azumi::live_impl(component = "like_button")]
impl LikeState {
    pub fn toggle(&mut self) {
        // 1. Predictable update (runs instantly on client)
        if self.liked {
            self.count -= 1;
        } else {
            self.count += 1;
        }
        self.liked = !self.liked;
    }
}

#[azumi::component]
pub fn like_button<'a>(state: &'a LikeState) -> impl Component + 'a {
    html! {
        // data-bind ensures the count flips instantly
        <button on:click={state.toggle} class={if state.liked { "liked" } else { "" }}>
            {if state.liked { "‚ù§Ô∏è" } else { "ü§ç" }}
            <span data-bind="count">{state.count}</span>
        </button>
    }
}
```

### üîµ Server Action Pattern: Login Form (RPC)

Use this for data submission where you _want_ to wait for the server (e.g., validation, redirect).

```rust
#[derive(Deserialize)]
pub struct LoginPayload { email: String, pass: String }

#[azumi::action]
pub async fn login_user(data: LoginPayload) -> impl Component {
    // 1. Validate DB (unpredictable)
    if let Ok(user) = db::auth(&data.email, &data.pass).await {
        // 2. Return redirect or success UI
        return html! { <div id="login-box">"Welcome back, " {user.name} "!"</div> };
    }
    // 3. Return error UI
    html! { <div id="login-error" class="error">"Invalid credentials"</div> }
}

// In your view (Standard HTML Form):
// Note: 'submit' event triggers the action
html! {
    <form az-on="submit call login_user -> #login-box">
        <input name="email" type="email" />
        <input name="pass" type="password" />
        <button>"Login"</button>
    </form>
}
```

### üîå Integration Pattern: Hooking up `azumi.js`

If your buttons aren't working, you likely missed one of these 3 steps:

1.  **Add Script to Layout**:
    ```rust
    // In your root HTML layout (e.g. layout.rs)
    <script src="azumi.js" />
    ```
2.  **Register Routes in `main.rs`**:
    ```rust
    // This serves the JS file at /azumi.js
    .merge(azumi::action::register_actions(Router::new()))
    ```
3.  **Use `az-on` or `on:click`**:
    The script only listens for events on elements with these attributes.

---

## ÔøΩüì¶ Asset Pipeline & Optimization

Azumi includes a production-ready asset pipeline that handles hashing, rewriting, and optimization automatically.

### 1. Automatic Asset Hashing (Cache Busting)

-   Place your static assets (images, fonts, etc.) in the `demo/static/` directory.
-   At build time, Azumi moves them to `target/assets/` and renames them with a content hash:
    -   `static/logo.png` -> `assets/logo.a8b9c7d6.png`
-   This enables **immutable caching** (1 year cache lifetime), as file names change whenever content changes.

### 2. Automatic Path Rewriting

You do not need to manually import or reference hashed files. Just use the original path in your `html!` macro:

```rust
html! {
    // Write this:
    <img src="/static/logo.png" />

    // Compiler outputs this automatically:
    // <img src="/assets/logo.a8b9c7d6.png" />
}
```

-   The macro reads `assets_manifest.json` at compile time to rewrite paths.
-   Works for `src`, `href` (link tags), and `srcset`.

### 3. CSS Minification

-   Styles defined in `<style>` blocks are automatically parsed and minified at compile time.
-   Comments and whitespace are removed to reduce payload size.
-   No configuration needed.

---

## üèóÔ∏è Component Fundamentals

### Basic Component Structure

```rust
#[azumi::component]
pub fn MyComponent(title: &str, count: i32) -> impl Component {
    html! {
        <div class={container}>
            <h1 class={title}>{title}</h1>
            <p>"Count: " {count}</p>
        </div>
        <style>
            .container { padding: "1rem"; }
            .title { font-size: "1.5rem"; color: "#333"; }
        </style>
    }
}
```

### Component with Children

```rust
#[azumi::component]
pub fn Container(children: impl Component) -> impl Component {
    html! {
        <div class={container}>
            {children}
        </div>
        <style>
            .container { padding: "1rem"; border: "1px solid #ddd"; }
        </style>
    }
}

// Usage with curly braces
@Container {
    <p>"Content inside container"</p>
    <div>"Multiple elements"</div>
}
```

### Component Composition

```rust
#[azumi::component]
pub fn Card<'a>(title: &'a str, content: &'a str) -> impl Component + 'a {
    html! {
        <div class={card}>
            <h3 class={title}>{title}</h3>
            <p>{content}</p>
        </div>
        <style>
            .card { border: "1px solid #eee"; padding: "1rem"; }
            .title { font-weight: "bold"; margin-bottom: "0.5rem"; }
        </style>
    }
}

#[azumi::component]
pub fn Dashboard() -> impl Component {
    html! {
        <div>
            @Card(title="Welcome", content="Getting started")
            @Card(title="Features", content="Type-safe components")
        </div>
    }
}
```

---

## üîç Search Engine Optimization (SEO)

### Automatic SEO (Recommended)

Azumi provides **Automatic SEO** via the `#[azumi::page]` macro. This infers metadata directly from your Rust code components, generating `<title>`, `<meta name="description">`, OpenGraph, and Twitter Card tags automatically.

#### How to use:

1.  Use `#[azumi::page]` instead of `#[azumi::component]` for your page root.
2.  Use the function name for the Title (e.g., `fn about_us` -> "About Us").
3.  Use doc comments (`///`) for the Description.

```rust
/// About Us
/// We are a team of passionate developers building the future of web frameworks.
#[azumi::page]
pub fn about_us() -> impl Component {
    html! {
        <h1>"About Us"</h1>
    }
}
```

**Generated HTML:**

```html
<title>About Us | My App</title>
<meta name="description" content="We are a team of passionate developers..." />
<meta property="og:title" content="About Us | My App" />
<meta
    property="og:description"
    content="We are a team of passionate developers..."
/>
```

#### Context Awareness & Page Metadata

The `#[azumi::page]` macro sets thread-local context that the `Layout` component can read. This means you **don't** need to pass title/description props down through your component tree.

**Custom Layout Implementation:**

If you are building a custom root layout, you must call `render_automatic_seo()` inside your `<head>` tag to inject the metadata.

```rust
#[azumi::component]
pub fn MyCustomLayout(children: impl Component) -> impl Component {
    html! {
       <!DOCTYPE html>
       <html lang="en">
       <head>
           <meta charset="utf-8" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />

           // 1. Inject Automatic SEO tags here
           // This pulls title/desc from the inner #[azumi::page]
           {azumi::seo::render_automatic_seo()}

           // 2. Inject Client Runtime (Required for interactivity)
           <script src="azumi.js" />
       </head>
       <body>
           {children}
       </body>
       </html>
    }
}
```

### üìã Schema.org JSON-LD Structured Data

Azumi supports generating Schema.org structured data for SEO through the `#[schema]` derive macro.

#### Basic Schema Support

```rust
use azumi::Schema;

#[derive(Schema)]
#[schema(type = "BlogPosting")]
pub struct Article {
    pub headline: String,
    pub author: String,
    pub date_published: String,
    #[schema(skip)]
    pub internal_id: String, // Skip this field in JSON-LD
}

#[azumi::component]
pub fn ArticlePage(article: &Article) -> impl Component {
    html! {
        <html>
        <head>
            {head! {
                title: &article.headline,
                description: "Read this article about web development"
            }}
            {article.to_schema_script()} // ‚Üê Generates JSON-LD script
        </head>
        <body>
            <article>
                <h1>{article.headline}</h1>
                <p>"By " {article.author} " on " {article.date_published}</p>
                <div>"Article content goes here..."</div>
            </article>
        </body>
        </html>
    }
}
```

#### Custom Field Names

```rust
#[derive(Schema)]
pub struct Product {
    pub name: String,
    #[schema(name = "description")]
    pub product_description: String,
    pub price: f64,
    #[schema(name = "image")]
    pub product_image_url: String,
}

// Generates: {
//   "@type": "Product",
//   "name": "...",
//   "description": "...", // Note: camelCase -> original name
//   "price": ...,
//   "image": "..."
// }
```

#### Schema Types

Common Schema.org types:

| Type           | Use Case                  | Example Usage               |
| -------------- | ------------------------- | --------------------------- |
| `Article`      | Blog posts, news articles | News sites, blogs           |
| `BlogPosting`  | Blog articles             | Personal/professional blogs |
| `Product`      | E-commerce products       | Online stores               |
| `Organization` | Companies, teams          | About pages                 |
| `Person`       | Individual profiles       | Team pages, author bios     |
| `Event`        | Events, webinars          | Event listings              |
| `Recipe`       | Cooking instructions      | Food blogs                  |
| `VideoObject`  | Video content             | YouTube embeds              |
| `WebSite`      | Website information       | Site-wide metadata          |

#### Complex Schema Example

```rust
#[derive(Schema)]
#[schema(type = "WebSite")]
pub struct Website {
    pub name: String,
    pub url: String,
    pub description: String,
    pub potential_action: SearchAction,
}

#[derive(Schema)]
pub struct SearchAction {
    pub target: String,
    pub query_input: String,
}

#[azumi::component]
pub fn WebsiteLayout() -> impl Component {
    let website = Website {
        name: "My Azumi App".to_string(),
        url: "https://myapp.com".to_string(),
        description: "A modern web application".to_string(),
        potential_action: SearchAction {
            target: "https://myapp.com/search?q={search_term_string}".to_string(),
            query_input: "search_term_string".to_string(),
        },
    };

    html! {
        <html>
        <head>
            {website.to_schema_script()}
        </head>
        <body>
            <div>"Website content"</div>
        </body>
        </html>
    }
}
```

### üìÑ Manual SEO (Head Meta Tags)

For fine-grained control or when not using `#[azumi::page]`, use the `head!` macro. It generates complete HTML head meta tags including title, description, and Open Graph/Twitter card tags.

#### Basic Head Meta

```rust
use azumi::head;

#[azumi::component]
pub fn Page() -> impl Component {
    html! {
        <html>
        <head>
            {head! {
                title: "My Azumi App",
                description: "A type-safe Rust web framework"
            }}
        </head>
        <body>
            <h1>"Welcome to Azumi"</h1>
        </body>
        </html>
    }
}
```

#### Full Meta with Social Sharing

```rust
#[azumi::component]
pub fn BlogPost() -> impl Component {
    let title = "Building with Azumi Live";
    let description = "Learn how to create reactive UI components";

    html! {
        <html>
        <head>
            {head! {
                title: title,
                description: description,
                image: "/static/azumi-preview.jpg",
                url: "https://myapp.com/blog/azumi-live",
                type: "article"
            }}
        </head>
        <body>
            <article>
                <h1>{title}</h1>
                <p>{description}</p>
            </article>
        </body>
        </html>
    }
}
```

#### Dynamic Meta Values

```rust
#[azumi::component]
pub fn ProductPage(product: &'a Product) -> impl Component + 'a {
    html! {
        <html>
        <head>
            {head! {
                title: format!("{} - {} | My Store", product.name, product.category),
                description: format!("Buy {} for ${}. {} {}", product.name, product.price, product.brand, product.description),
                image: product.image_url,
                url: format!("https://mystore.com/products/{}", product.id),
                type: "product"
            }}
        </head>
        <body>
            <div>
                <h1>{product.name}</h1>
                <p>"$" {product.price}</p>
            </div>
        </body>
        </html>
    }
}
```

#### Head Meta Field Reference

| Field         | Required | Description          | Generated Tags                                                       |
| ------------- | -------- | -------------------- | -------------------------------------------------------------------- |
| `title`       | ‚úÖ Yes   | Page title           | `<title>`, `og:title`, `twitter:title`                               |
| `description` | ‚úÖ Yes   | Page description     | `<meta name="description">`, `og:description`, `twitter:description` |
| `image`       | ‚ùå No    | Social sharing image | `og:image`, `twitter:image`, `twitter:card="summary_large_image"`    |
| `url`         | ‚ùå No    | Canonical URL        | `og:url`                                                             |
| `type`        | ‚ùå No    | Content type         | `og:type` (defaults to "website")                                    |

#### Meta Tag Output Examples

**Minimal (title + description only):**

```html
<title>My Page</title>
<meta name="description" content="Page description" />
<meta property="og:title" content="My Page" />
<meta property="og:description" content="Page description" />
<meta property="og:type" content="website" />
<meta name="twitter:title" content="My Page" />
<meta name="twitter:description" content="Page description" />
<meta name="twitter:card" content="summary" />
```

**Full (with image, URL, type):**

```html
<title>My Article</title>
<meta name="description" content="Article description" />
<meta property="og:title" content="My Article" />
<meta property="og:description" content="Article description" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/article" />
<meta property="og:image" content="/image.jpg" />
<meta name="twitter:image" content="/image.jpg" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="My Article" />
<meta name="twitter:description" content="Article description" />
```

#### SEO Best Practices

```rust
#[azumi::component]
pub fn SEOOptimizedPage() -> impl Component {
    let page_title = "Azumi Live Guide - Type-Safe Reactive UI";
    let description = "Complete guide to building reactive web applications with Azumi Live. Zero JavaScript, full type safety.";
    let keywords = "rust, web framework, reactive ui, type-safe, azumi";

    html! {
        <html lang="en">
        <head>
            {head! {
                title: page_title,
                description: description,
                image: "/static/azumi-social-preview.jpg",
                url: "https://azumi.dev/guide",
                type: "article"
            }}
            // Additional SEO meta tags
            <meta name="keywords" content={keywords} />
            <meta name="author" content="Azumi Team" />
            <meta name="robots" content="index, follow" />
        </head>
        <body>
            <main>
                <h1>"Azumi Live Guide"</h1>
                <p>{description}</p>
            </main>
        </body>
        </html>
    }
}
```

---

## üé® Styling System

### CSS Scoping: Component vs Global

````rust
#[azumi::component]
pub fn StyledComponent() -> impl Component {
    html! {
        <div class={container}>
            <h1 class={local_heading}>"Scoped (blue)"</h1>
            <h2 class={global_heading}>"Global (purple)"</h2>
        </div>

        // Global styles - NOT scoped (use string literals)
        <style global>
            body { font-family: "Inter, sans-serif"; }
            .global_heading { color: "purple"; }
        </style>

        // Component styles - automatically scoped (become variables)
        <style>
            .local_heading { color: "blue"; }
            .container { padding: "1rem"; }
        </style>
    }
}

### üé® Integrating Design Systems

Azumi is unopinionated about design. You can use any CSS methodology, but **CSS Variables (Custom Properties)** are highly recommended for theming.

**Recommended Pattern:**

1.  Define your variables in a `global` style block (usually in your root layout).
2.  Use them in your components via `var(--my-var)`.

```rust
// In your root layout
<style global>
    :root {
        --primary-color: "#3b82f6";
        --spacing-md: "1rem";
    }
</style>
````

**Note:** The examples in this guide may use arbitrary variable names for demonstration. Always check the project's specific CSS definition before hallucinating variable names.

````

### Dynamic CSS with Custom Properties

```rust
#[azumi::component]
pub fn ProgressMeter(completion: f64, accent_color: &str) -> impl Component {
    html! {
        <div class={meter}>
            // style={} ONLY allows CSS custom properties (--variables)
            <div class={fill} style={--progress: completion; --accent: accent_color}></div>
        </div>
        <style>
            .meter {
                width: "100%";
                height: "20px";
                background: "#eee";
                border-radius: "10px";
                overflow: "hidden";
            }
            .fill {
                height: "100%";
                background: "var(--accent, #2196f3)";
                width: "calc(var(--progress) * 100%)";
                transition: "width 0.3s ease";
            }
        </style>
    }
}
````

**‚ö†Ô∏è Important**: Only CSS custom properties (`--var-name`) are allowed in `style={}` attributes. Direct properties like `style={width: "50%"}` cause compile errors.

### CSS Validation Rules

Azumi validates all CSS at compile time:

**Allowed:**

-   Standard CSS properties with quoted values
-   CSS custom properties (`--variable-name`)
-   CSS functions like `calc()`, `var()`, etc.

**Not Allowed:**

-   External CSS imports (`@import`)
-   Inline CSS properties without custom properties
-   Invalid CSS syntax

---

## üßÆ Control Flow & Logic

### @let Pattern (Local Variables)

```rust
#[azumi::component]
pub fn LetExample() -> impl Component {
    html! {
        <div>
            // Basic variable declaration
            @let name = "Azumi";
            <p>"Hello, " {name} "!"</p>

            // Calculated values
            @let items = vec!["Item 1", "Item 2", "Item 3"];
            @let item_count = items.len();
            <p>"Total items: " {item_count}</p>

            // Derived calculations
            @let base_price = 100.0;
            @let tax_rate = 0.08;
            @let total_price = base_price * (1.0 + tax_rate);
            <div class={result}>
                <p>"Total: $" {total_price:.2}</p>
            </div>

            // With conditional logic
            @let score = 85;
            @let grade = if score >= 90 {
                "A"
            } else if score >= 80 {
                "B"
            } else {
                "C"
            };
            <p>"Grade: " {grade}</p>
        </div>
        <style>
            .result { background: "#f0f0f0"; padding: "0.5rem"; }
        </style>
    }
}
```

### Conditional Rendering (@if)

```rust
html! {
    // Simple conditional
    @if state.active {
        <div>"Active"</div>
    }

    // With else
    @if state.user_type == "admin" {
        <div>"Admin Panel"</div>
    } else {
        <div>"User Dashboard"</div>
    }

    // Conditional class application
    <div class={if state.active { "active_class" } else { "inactive_class" }}>
        "Content"
    </div>
}
```

### Loops (@for)

```rust
html! {
    // Basic loop
    @for item in &state.items {
        <div>{item}</div>
    }

    // Loop with index
    @for (i, item) in state.items.iter().enumerate() {
        <div>{i + 1}". " {item}</div>
    }

    // Empty state handling
    @if state.items.is_empty() {
        <p>"No items found"</p>
    } else {
        @for item in &state.items {
            <div>{item}</div>
        }
    }
}
```

### Pattern Matching (@match)

```rust
#[azumi::component]
pub fn StatusDisplay(status: &str) -> impl Component {
    html! {
        <div>
            @match status {
                "loading" => {
                    <p class={loading}>"Loading..."</p>
                }
                "success" => {
                    <p class={success}>"Operation successful!"</p>
                }
                "error" => {
                    <p class={error}>"An error occurred"</p>
                }
                _ => {
                    <p>"Unknown status"</p>
                }
            }
        </div>
        <style>
            .loading { color: "blue"; }
            .success { color: "green"; }
            .error { color: "red"; }
        </style>
    }
}
```

---

## ‚ö° Live Interactive Components

### Live State Structure

```rust
#[azumi::live]
pub struct Counter {
    pub count: i32,
    pub active: bool,
}

#[azumi::live_impl(component = "counter_view")]
impl Counter {
    pub fn increment(&mut self) {
        self.count += 1;
    }

    pub fn toggle(&mut self) {
        self.active = !self.active;
    }

    // Async action (Optimistic + Server-Side)
    pub async fn load_data(&mut self) {
        self.active = true;
        tokio::time::sleep(std::time::Duration::from_secs(1)).await; // Non-blocking!
        self.count = 42;
    }
}
```

### Async Database Integration

You can use `sqlx` directly in your async live actions. The UI can update optimistically while the DB operation happens in the background.

```rust
impl TodoList {
    pub async fn add_todo(&mut self) {
        // 1. Optimistic Update (Instant feedback)
        self.todos.push(Todo { id: -1, text: self.input.clone() });
        let input_val = self.input.clone();
        self.input.clear();

        // 2. Real Async DB Operation
        sqlx::query("INSERT INTO todos (text) VALUES (?)")
            .bind(input_val)
            .execute(&*POOL) // Use a global or injected pool
            .await
            .unwrap();

        // 3. Re-fetch for consistency (updates IDs, etc.)
        self.refresh_from_db().await;
    }
}
```

### Live Component View

```rust
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a {
    html! {
        <div class={counter}>
            <div class={value}>{state.count}</div>
            <button class={btn} on:click={state.increment}>
                "Increment"
            </button>
            <p>"Status: " {if state.active { "Active" } else { "Inactive" }}</p>
        </div>
        <style>
            .counter { padding: "2rem"; text-align: "center"; }
            .value { font-size: "3rem"; margin: "1rem 0"; }
            .btn { padding: "1rem 2rem"; cursor: "pointer"; }
        </style>
    }
}
```

### Auto-Detection of Live Components

When the first parameter is `state: &T`, the component automatically detects live mode:

```rust
// Auto-wraps in <div az-scope="...">
#[azumi::component]
pub fn auto_detected_view<'a>(state: &'a MyState) -> impl Component + 'a {
    html! {
        <button on:click={state.my_action}>"Click me"</button>
    }
}
```

---

## üéØ Event Binding Systems

### Modern: on:event Syntax (Recommended)

```rust
<button on:click={state.increment}>"Click"</button>
<input on:input={state.update_text} />
<form on:submit={state.submit_form}>"Submit"</form>
```

### Local State (Client-Only `set`)

For temporary UI state (like dropdowns, modals, tabs) that doesn't need to involve the server, use the `set` action directly in the template.

````rust
// Toggle value (Client-side only, 0ms latency, no network)
<button az-on="click set is_open = !is_open">"Toggle"</button>

// Set literal value
### State Management: The Hybrid Optimistic Model

Azumi uses a **Hybrid Optimistic Model** for state management. This is the "Gold Standard" pattern you should always use.

1.  **User Trigger**: User performs an action (e.g., clicks "Like").
2.  **Optimistic Client Update (0ms)**: The browser immediately runs a compiled prediction (e.g., `liked = !liked`). This feels instant.
3.  **Server Synchronization**: The action is sent to the server. The server executes the *real* logic, signs the new state, and returns it.
4.  **Reconciliation**: The client seamlessly morphs to the server's signed state.

**Why not just use client state?**
Pure client state (like the now-removed `set` command) is "Zombie State". It looks alive but lacks the cryptographic signature from the server. The moment you interact with the server again, your unsigned local changes are rejected and overwritten.

**Best Practice:**
Always implement interactivity via `#[azumi::live_impl]` methods. The compiler automatically generates the optimistic prediction for you!

```rust
#[azumi::live_impl(component = "like_button")]
impl LikeState {
    pub fn toggle(&mut self) {
        // Compiler sees this and generates: "liked = !liked" for the client!
        self.liked = !self.liked;
    }
}
````

#### 2. Manual (Complex Logic)

For complex mutations (vectors, structs, arbitrary logic), explicitly define the prediction using `data-predict`.

```rust
// HTML
<button
    on:click={state.add_todo}
    data-predict="todos.push({ text: input, id: -1 })"
>
    "Add Todo"
</button>
```

**Key Benefits:**

-   **Zero Latency**: UI feels native.
-   **Automatic Synchronization**: If the server response differs from the prediction, Azumi automatically reconciles the state.
-   **Declarative**: No manual DOM manipulation.

---

## üõ†Ô∏è Developer Tools

Azumi includes built-in tools to improve the developer experience.

### Prevention of Browser Caching

During development, browsers may aggressively cache your JavaScript or static assets. Azumi provides a middleware to prevent this.

**Usage:**

In your `main.rs`:

```rust
// Use the devtools router which matches development routes
let app = Router::new()
    .merge(azumi::devtools::router())
    // ... your other routes
    // Apply the no-cache middleware (active only in debug mode)
    .layer(axum::middleware::from_fn(azumi::devtools::no_cache_middleware));
```

This ensures that `Cache-Control: no-cache` headers are automatically injected during `cargo run`, preventing stale pages.

---

## üìã Form Handling

### Basic Form with Live State

```rust
#[azumi::live]
pub struct ContactForm {
    pub submitted: bool,
}

#[azumi::live_impl]
impl ContactForm {
    pub fn submit(&mut self) {
        self.submitted = true;
    }

    pub fn reset(&mut self) {
        self.submitted = false;
    }
}

#[azumi::component]
pub fn contact_form_view<'a>(state: &'a ContactForm) -> impl Component + 'a {
    html! {
        @if state.submitted {
            <div>"Thank you for your message!"</div>
            <button on:click={state.reset}>"Send Another"</button>
        }

        @if !state.submitted {
            <form class={form}>
                <div class={field}>
                    <label>"Name"</label>
                    <input class={input} type="text" name="name" />
                </div>
                <div class={field}>
                    <label>"Email"</label>
                    <input class={input} type="email" name="email" />
                </div>
                <button class={btn} type="button" on:click={state.submit}>
                    "Submit"
                </button>
            </form>
        }
        <style>
            .form { display: "grid"; gap: "1rem"; max-width: "400px"; }
            .field { display: "grid"; gap: "0.5rem"; }
            .input { padding: "0.5rem"; border: "1px solid #ddd"; }
            .btn { padding: "0.75rem"; background: "#2196f3"; color: "white"; }
        </style>
    }
}
```

---

## üìã Form Binding & Data Attributes

### Data Bind Attributes for Optimistic UI

The `data-bind` attribute enables optimistic UI updates by binding state properties to DOM elements:

```rust
#[azumi::component]
pub fn LiveCounter(state: &Counter) -> impl Component {
    html! {
        <div class={counter}>
            <div class={value} data-bind="count">{state.count}</div>
            <p>"Status: "
                <span data-bind="active">
                    {if state.active { "Active ‚úì" } else { "Inactive ‚úó" }}
                </span>
            </p>
        </div>
        <style>
            .counter { padding: "2rem"; text-align: "center"; }
            .value { font-size: "3rem"; color: "#2196f3"; }
        </style>
    }
}
```

**How it works:**

-   The `data-bind="count"` attribute binds the `count` property from state
-   When a prediction updates `count`, the corresponding DOM element updates instantly
-   Supports nested properties: `data-bind="user.profile.name"`

### Form Binding with Structs

```rust
struct UserRegistration {
    username: String,
    email: String,
    password: String,
}

#[azumi::component]
pub fn RegistrationForm() -> impl Component {
    html! {
        <form class={form} bind={UserRegistration}>
            <input class={input} name="username" type="text" placeholder="Username" />
            <input class={input} name="email" type="email" placeholder="Email" />
            <input class={input} name="password" type="password" placeholder="Password" />
            <button type="submit">"Register"</button>
        </form>
        <style>
            .form { display: "grid"; gap: "1rem"; max-width: "400px"; }
            .input { padding: "0.5rem"; border: "1px solid #ddd"; }
        </style>
    }
}
```

### Nested Form Binding

```rust
struct UserProfile {
    name: String,
    address: Address,
}

struct Address {
    street: String,
    city: String,
}

#[azumi::component]
pub fn ProfileForm() -> impl Component {
    html! {
        <form bind={UserProfile}>
            <input name="name" type="text" placeholder="Full name" />
            <input name="address.street" type="text" placeholder="Street address" />
            <input name="address.city" type="text" placeholder="City" />
        </form>
    }
}
```

**Form Binding Rules:**

-   Field names must match struct field names (case-sensitive)
-   Nested fields use dot notation: `address.street`
-   Compile-time validation prevents typos in field names
-   Supports all form elements: `<input>`, `<select>`, `<textarea>`

---

## üß© Component Composition Patterns

### Multiple Live Components Together

```rust
#[azumi::live]
pub struct TabState {
    pub active_index: i32,
}

#[azumi::live_impl(component = "tabs_view")]
impl TabState {
    pub fn select_0(&mut self) { self.active_index = 0; }
    pub fn select_1(&mut self) { self.active_index = 1; }
    pub fn select_2(&mut self) { self.active_index = 2; }
}

#[azumi::component]
pub fn tabs_view<'a>(state: &'a TabState) -> impl Component + 'a {
    html! {
        <div>
            <div class={tabs}>
                <button class={if state.active_index == 0 { "tab active" } else { "tab" }}
                        on:click={state.select_0}>"Tab 1"</button>
                <button class={if state.active_index == 1 { "tab active" } else { "tab" }}
                        on:click={state.select_1}>"Tab 2"</button>
                <button class={if state.active_index == 2 { "tab active" } else { "tab" }}
                        on:click={state.select_2}>"Tab 3"</button>
            </div>
            <div>
                @match state.active_index {
                    0 => { <p>"Content for tab 1"</p> }
                    1 => { <p>"Content for tab 2"</p> }
                    2 => { <p>"Content for tab 3"</p> }
                    _ => { <p>"Unknown tab"</p> }
                }
            </div>
        </div>
        <style>
            .tabs { display: "flex"; gap: "0.5rem"; }
            .tab { padding: "0.5rem 1rem"; cursor: "pointer"; }
            .active { background: "#2196f3"; color: "white"; }
        </style>
    }
}
```

### Layout Components

```rust
#[azumi::component]
pub fn PageLayout(children: impl Component) -> impl Component {
    html! {
        <div class={page}>
            <header class={header}>
                <h1>"My App"</h1>
            </header>
            <main>{children}</main>
        </div>
        <style>
            .page { max-width: "800px"; margin: "0 auto"; padding: "2rem"; }
            .header { border-bottom: "1px solid #eee"; margin-bottom: "2rem"; }
        </style>
    }
}
```

---

## üîç HTML Structure Validation

Azumi validates HTML structure at compile time:

### Required Attributes

```rust
// Images require alt text
<img src="image.jpg" alt="Description" />

// Inputs require labels (accessibility)
<label for="name">"Name"</label>
<input id="name" type="text" />

// Links need href
<a href="/page">"Link text"</a>
```

### Valid HTML Structure

```rust
// ‚úÖ Valid structure
<div>
    <h1>"Title"</h1>
    <p>"Content"</p>
</div>

// ‚ùå Invalid - missing required elements
<img src="test.jpg" />  // Missing alt attribute
```

---

## ‚ôø Accessibility Features

### Semantic HTML

```rust
// Use semantic elements
<nav> {/* Navigation */}
<main> {/* Main content */}
<article> {/* Article content */}
<section> {/* Section content */}
<aside> {/* Sidebar content */}

// Proper heading hierarchy
<h1>"Page Title"</h1>
<h2>"Section Title"</h2>
<h3>"Subsection Title"</h3>
```

### ARIA Attributes

```rust
<button aria-label="Close dialog" on:click={state.close}>
    "√ó"
</button>

<div role="alert" aria-live="polite">
    {state.message}
</div>
```

### Focus Management

```rust
// Ensure focusable elements
<button on:click={state.action}>"Click me"</button>
<input on:input={state.update} />

// Skip links for keyboard users
<a href="#main-content" class={skip_link}>"Skip to main content"</a>
```

---

## üìä Prediction System Details

### How Optimistic UI Works

```
User clicks on:click={state.increment}
    ‚Üì
1. INSTANT: Execute prediction locally (0ms latency!)
    ‚Üì
2. ASYNC: Send request to server
    ‚Üì
3. RECONCILE: Server returns HTML, morph into DOM
    ‚Üì
4. VERIFY: If prediction was wrong, server wins
```

### Supported Prediction Patterns

| Rust Code Pattern  | Generated Prediction     |
| ------------------ | ------------------------ |
| `self.x = !self.x` | `x = !x` (toggle)        |
| `self.x = true`    | `x = true` (literal)     |
| `self.x = false`   | `x = false` (literal)    |
| `self.x += 1`      | `x = x + 1` (increment)  |
| `self.x -= 1`      | `x = x - 1` (decrement)  |
| `self.x = value`   | `x = value` (assignment) |

### Complex Logic (No Prediction)

```rust
// This runs server-only, no client prediction
pub async fn complex_action(&mut self) {
    // Database operations
    // External API calls
    // Complex calculations
    // These cannot be predicted
}
```

---

## üîß Component Props System

### Required Props

```rust
#[azumi::component]
pub fn Card(title: &str, content: &str) -> impl Component {
    html! {
        <div>
            <h3>{title}</h3>
            <p>{content}</p>
        </div>
    }
}

// Usage:
@Card(title = "Hello", content = "World")
```

### Optional Props with Defaults

```rust
#[azumi::component]
pub fn Button(
    label: &str,
    #[prop(default = "primary")] variant: &str,
    #[prop(default = false)] disabled: bool,
    #[prop(default = "medium")] size: &str,
) -> impl Component {
    html! {
        <button disabled={disabled} class={format!("btn btn-{} btn-{}", variant, size)}>
            {label}
        </button>
    }
}

// Usage:
@Button(label = "Click me")  // Uses all defaults
@Button(label = "Submit", variant = "secondary", disabled = true)
```

### Props with Lifetimes

```rust
#[azumi::component]
pub fn UserCard<'a>(user: &'a User) -> impl Component + 'a {
    html! {
        <div>
            <h3>{user.name}</h3>
            <p>{user.email}</p>
        </div>
    }
}
```

---

## üìÅ File Structure & Organization

### Recommended Project Structure

```
src/
‚îú‚îÄ‚îÄ main.rs                 # Axum router setup
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs             # Component exports
‚îÇ   ‚îú‚îÄ‚îÄ button.rs          # Reusable Button component
‚îÇ   ‚îú‚îÄ‚îÄ card.rs            # Card component
‚îÇ   ‚îî‚îÄ‚îÄ layout.rs          # Layout components
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs             # Page exports
‚îÇ   ‚îú‚îÄ‚îÄ home.rs            # Home page component
‚îÇ   ‚îú‚îÄ‚îÄ about.rs           # About page component
‚îÇ   ‚îî‚îÄ‚îÄ dashboard.rs       # Dashboard page
‚îú‚îÄ‚îÄ state/
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs             # State exports
‚îÇ   ‚îú‚îÄ‚îÄ counter.rs         # Counter live state
‚îÇ   ‚îî‚îÄ‚îÄ user.rs            # User live state
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ mod.rs
    ‚îî‚îÄ‚îÄ helpers.rs         # Utility functions
```

### Router Setup

```rust
use axum::Router;

fn main() {
    let app = Router::new()
        // Register all Azumi actions
        .merge(azumi::action::register_actions())
        // Add your routes
        .route("/", axum::routing::get(homepage_handler))
        .route("/lesson-0", axum::routing::get(lesson0_handler));

    axum::Server::bind(&"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

---

## ‚ö†Ô∏è Common Mistakes & Solutions

### ‚ùå Missing Component Link

```rust
// WRONG - missing component link
#[azumi::live_impl]
impl Counter { /* ... */ }

// CORRECT
#[azumi::live_impl(component = "counter_view")]
impl Counter { /* ... */ }
```

### ‚ùå Unquoted CSS Values

```rust
// WRONG - causes compile errors
.btn { padding: 1rem; }

// CORRECT
.btn { padding: "1rem"; }
```

### ‚ùå Using Hyphens in Class Names

```rust
// WRONG - can't be a Rust identifier
.my-button { }
<div class={my-button}></div>  // Error!

// CORRECT
.my_button { }
<div class={my_button}></div>
```

### ‚ùå Closure Event Handlers

```rust
// WRONG - don't use closures
<button on:click={|| state.increment()}>

// CORRECT - direct method reference
<button on:click={state.increment}>
```

## üîê Security & Authentication

### Automatic State Signing (Anti-Tampering)

Azumi protects all Live Component state with **HMAC-SHA256 signatures**.

-   **Mechanism:** When state is serialized to the client, it is signed with a server-side secret.
-   **Protection:** If a client manipulates the `az-scope` JSON (e.g. changing `is_admin: false` to `true`), the signature verification will fail on the next action.
-   **Result:** The server rejects the action with `400 Bad Request`.

You do not need to "enable" this; it is on by default for all `#[azumi::live]` components.

### Authentication Middleware

### The Data Bridge Pattern

Azumi components are pure Rust structs that know nothing about HTTP requests. Middleware is pure HTTP logic. You bridge them in your **Handler**.

You don't need to change Azumi internals to support auth; you just need to **pass the data**.

#### 1. The Guard (Middleware)

Standard Axum middleware validates the request and puts a `User` object into the request's "pocket" (extensions).

```rust
async fn auth_middleware(req: Request, next: Next) -> Result<Response, StatusCode> {
    // 1. Validate Session
    let user = decode_session_cookie(&req)?;

    // 2. data-passing: Put user in the request extensions
    req.extensions_mut().insert(user);

    Ok(next.run(req).await)
}
```

#### 2. The Bridge (Handler)

Your handler extracts that `User` object and gives it to the Azumi state.

```rust
async fn my_page_handler(
    // 3. Extract from request extensions
    Extension(user): Extension<User>
) -> impl IntoResponse {
    // 4. Initialize Azumi State
    let state = MyState {
        username: user.username,
        role: user.role
    };

    // 5. Render
    azumi::render_to_string(&MyComponent::render(
        MyComponent::Props::builder().state(&state).build().unwrap()
    ))
}
```

#### 3. The UI (Component)

The component just receives data. It doesn't care if it came from a cookie, a JWT, or a mock.

```rust
#[azumi::live]
pub struct MyState {
    pub username: String, // Just data!
}
```

### The Reusable Extractor Pattern (Recommended)

Instead of manually extracting `Extension` or implementing complex traits in every handler, we recommend creating a shared `CurrentUser` extractor in your project's infrastructure.

1.  **Define Infrastructure (Once)**:
    Create a reusable extractor in `auth.rs`:

    ```rust
    // auth.rs
    pub struct CurrentUser(pub Option<User>);

    #[async_trait]
    impl<S> FromRequestParts<S> for CurrentUser where S: Send + Sync {
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            let Extension(user) = parts.extract::<Extension<Option<User>>>().await.unwrap_or(Extension(None));
            Ok(CurrentUser(user))
        }
    }
    ```

2.  **Use it Everywhere**:
    Now your handlers remain clean and Type-Safe:

    ```rust
    // page.rs
    use crate::auth::CurrentUser;

    pub async fn my_handler(
        // Look how clean this is!
        CurrentUser(user): CurrentUser
    ) -> impl IntoResponse {
        // Initialize state directly from the user object
        let state = MyState {
            name: user.map(|u| u.name)
        };
        azumi::render(&view(&state))
    }
    ```

### ‚ùå Missing State Reference in Component

```rust
// WRONG - state must be first param for live components
#[azumi::component]
pub fn counter_view() -> impl Component { }

// CORRECT
#[azumi::component]
pub fn counter_view<'a>(state: &'a Counter) -> impl Component + 'a { }
```

### ‚ùå Using style Attribute Incorrectly

```rust
// WRONG - direct CSS properties
<div style={width: "50%"; background: "red"}></div>

// CORRECT - only CSS custom properties
<div style={--width: "0.5"; --color: "red"}></div>
```

### ‚ùå Missing Script Include

```rust
// Compiler automatically handles injection for standard layouts.
// Only required manually for non-standard fragments:
{azumi::azumi_script()}
```

---

## üöÄ Performance Considerations

### Optimized Patterns

```rust
// ‚úÖ Good - minimal re-renders
#[azumi::component]
pub fn OptimizedComponent(state: &'a MyState) -> impl Component + 'a {
    html! {
        @let computed_value = expensive_calculation(&state.data);
        <div>{computed_value}</div>
    }
}

// ‚úÖ Good - conditional rendering
@if state.visible {
    @ExpensiveComponent(data=state.data)
}
```

### Avoid Anti-Patterns

```rust
// ‚ùå Bad - unnecessary computations in template
<div>
    {expensive_function(&state.data)}  // Runs on every render
</div>

// ‚ùå Bad - large components
// Break into smaller components instead
```

---

## üîß Debugging & Development

### Development Server

```bash
# Run the demo to see examples
cd demo
cargo run
# Visit http://localhost:3000
```

### Client Runtime Integration

### Client Runtime Integration

The client runtime **must be manually included** if you want interactive features.

```rust
#[azumi::component]
pub fn InteractivePage() -> impl Component {
    html! {
        <html>
        <head>
            // No manual script tags needed!
            // Manually include the runtime for interactivity
            <script src="azumi.js" />
        </head>
        <body>
            // Your components here
        </body>
        </html>
    }
}
```

If you ever need to manually place it (e.g. for specific ordering), use `<script src="azumi.js" />`.

### CSS ID Handling

```rust
// IDs are NOT scoped like classes - they remain global
<style>
    #unique_id { color: "blue"; }  // ID not scoped
    .my_class { padding: "1rem"; } // Class gets scoped
</style>

// Usage
<div id={unique_id} class={my_class}>
    "Content"
</div>
```

### Development Server

### Error Messages

Common error patterns and solutions:

1. **CSS Parsing Errors**: Check all values are quoted
2. **Component Link Errors**: Ensure `#[azumi::live_impl(component = "name")]` matches component name
3. **Event Binding Errors**: Use `on:click={state.method}` not closures
4. **HTML Validation Errors**: Check required attributes (alt, href, labels)

---

## üß™ Testing Patterns

Azumi provides a specialized `test` module for verifying components without a browser.

### 1. Unit Testing Rendering

Verify that your HTML structure and classes are correct.

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use azumi::test;

    #[test]
    fn test_card_render() {
        let props = Card::Props::builder()
            .title("Hello".into())
            .build()
            .unwrap();

        let html = test::render(&Card::render(props));

        // Assert existence of selectors and text content
        test::assert_selector(&html, ".card_title", Some("Hello"));
    }
}
```

### 2. Simulating Live Logic

Verify your state transitions and action logic.

```rust
#[test]
fn test_counter_logic() {
    // 1. Initialize simulation with state
    let mut sim = test::simulate(Counter { count: 0 });

    // 2. Perform actions directly
    sim.act(Counter::increment);

    // 3. Assert new state
    assert_eq!(sim.state.count, 1);
}
```

---

## üñºÔ∏è Image Optimization

Azumi automatically optimizates images to improve Core Web Vitals (LCP).

### Automatic Enhancements

When you use a standard `<img>` tag, the compiler enhances it:

```rust
// Input
<img src="/photo.jpg" alt="A photo" width="800" height="600" />

// Output (Compiler Generated)
<img
    src="/photo.jpg"
    alt="A photo"
    width="800"
    height="600"
    loading="lazy"
    decoding="async"
/>
```

### Optimization Rules

1.  **Lazy Loading:** Added by default unless `loading="eager"` is specified.
2.  **Async Decoding:** Added by default for smoother scrolling.
3.  **Asset Hashing:** `src` paths are rewritten to include content hashes for long-term caching (e.g. `/assets/photo.a1b2c3.jpg`).

---

## üìö Quick Reference

| Feature       | Syntax                                 | Example                                              |
| ------------- | -------------------------------------- | ---------------------------------------------------- |
| Component     | `#[azumi::component]`                  | `#[azumi::component] fn MyComp() -> impl Component`  |
| Live State    | `#[azumi::live]`                       | `#[azumi::live] pub struct State { }`                |
| Live Methods  | `#[azumi::live_impl]`                  | `#[azumi::live_impl(component = "view")] impl State` |
| Event         | `on:event={state.method}`              | `on:click={state.increment}`                         |
| Class         | `class={class_name}`                   | `class={my_button}`                                  |
| Style         | `<style>` or `<style global>`          | `<style> .btn { } </style>`                          |
| Dynamic Style | `style={--var: value}`                 | `style={--color: "red"}`                             |
| Conditional   | `{if cond { a } else { b }}`           | `{if active { "On" } else { "Off" }}`                |
| Loop          | `@for item in items { }`               | `@for item in &list { <div>{item}</div> }`           |
| Pattern Match | `@match value { }`                     | `@match status { "ok" => {} _ => {} }`               |
| Local Var     | `@let name = value;`                   | `@let total = price * quantity;`                     |
| Children      | `@Component { }`                       | `@Container { <p>"Content"</p> }`                    |
| Head Meta     | `head! { title: "", description: "" }` | `head! { title: "Page", desc: "Desc" }`              |
| Schema        | `#[derive(Schema)]`                    | `#[schema(type = "BlogPosting")]`                    |
| Form Bind     | `bind={StructName}`                    | `form bind={UserRegistration}`                       |
| Data Bind     | `data-bind="property"`                 | `data-bind="count"`                                  |
| Client Script | `Auto / {azumi::azumi_script()}`       | `html! { <head>...` (Auto)                           |
| Text          | Quoted strings                         | `"Hello world"`                                      |

---

## üñºÔ∏è Image Optimization

Azumi automatically optimizes images at compile time. You do not need a special image component.

### Automatic Attributes

Standard `<img>` tags automatically get performance attributes injected by the compiler:

```rust
// You write:
<img src="/photo.jpg" alt="Description" />

// Compiler generates:
<img src="/photo.jpg" alt="Description" loading="lazy" decoding="async" />
```

### Overriding Defaults

You can manually override these defaults for "above the fold" hero images:

```rust
// Hero image (loads immediately)
<img src="/hero.jpg" alt="Hero" loading="eager" />
// Compiler respects your choice and does NOT inject loading="lazy"
```

### Responsive Images

Use standard HTML `srcset` for responsive sizing. The compiler leaves these alone (while still adding lazy/async if omitted).

```rust
<img
    src="/photo-800.jpg"
    srcset="/photo-400.jpg 400w, /photo-800.jpg 800w"
    sizes="(max-width: 600px) 100vw, 800px"
    alt="Responsive"
/>
```

---

## üöÄ Deployment & Production

### 1. Zero-Dependency Binary

Azumi compiles to a single binary.

```bash
cargo build --release
```

### 2. Assets in Production

Azumi uses a `build.rs` script to hash assets. In production, you must serve the `target/assets` directory.

**Important**: The `demo` example hardcodes the asset path to `env!("OUT_DIR")`. For real production apps, you should configure this via an environment variable.

```rust
// Recommended Production Pattern
let assets_path = std::env::var("ASSETS_DIR").unwrap_or("assets".to_string());
app.nest_service("/assets", ServeDir::new(assets_path));
```

---

## üéØ Key Takeaways

1. **Write Rust, get JavaScript**: The compiler does the heavy lifting
2. **Quote everything**: CSS values, text content, class names
3. **Component link required**: Live state needs `#[azumi::live_impl(component = "name")]`
4. **Event binding is declarative**: `on:click={state.method}` not closures
5. **Predictions are optimistic**: Server always wins if wrong
6. **CSS scoping is automatic**: No manual CSS management needed
7. **Forms are type-safe**: Compile-time validation for accessibility
8. **Performance is built-in**: Compiler optimizations and efficient rendering

This guide covers all aspects of Azumi development. Use it as your comprehensive reference for building type-safe, performant web applications with Rust!
